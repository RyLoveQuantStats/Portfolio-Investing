Directory structure:
└── Portfolio Investing/
    ├── NQ_Efficient_Frontier_Project_Outline.docx
    └── scripts/
        ├── bonds.py
        ├── config.py
        ├── equities.py
        ├── portfolio.py
        └── __pycache__/

================================================
File: NQ_Efficient_Frontier_Project_Outline.docx
================================================
[Non-text file]


================================================
File: scripts/bonds.py
================================================
# bonds.py

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import pandas_datareader.data as web
from datetime import datetime
from config import Start_Date, End_Date

def get_bond_portfolio(start_date, end_date, T=0.25, plot_results=True):
    """
    Builds a bond "portfolio" based on roll-down valuation. It downloads Treasury 
    yields for maturities 2Y, 5Y, 10Y, 20Y, and 30Y from FRED, resamples the data 
    to quarterly snapshots, and then uses a roll-down model to compute the expected 
    annualized return for each bond over a holding period T (default: 0.25 years).
    
    For each quarter, it calculates the expected return on each bond using the formula:
         Expected Return = [ current_yield * maturity - y_new * (maturity - T) ] / T
    where y_new is obtained by linear interpolation on the current yield curve.
    
    Parameters:
        start_date (str): The start date (format 'YYYY-MM-DD').
        end_date (str): The end date (format 'YYYY-MM-DD').
        T (float): The holding period in years over which to roll down the yield curve (default 0.25 for a quarter).
        plot_results (bool): If True, plot the quarterly expected returns for each maturity.
        
    Returns:
        expected_returns_quarterly (pd.DataFrame): A DataFrame indexed by quarter with columns '2Y', '5Y', '10Y', '20Y', '30Y'
                                                   representing the computed expected annualized returns.
        overall_expected_return (float): A simple average expected annualized return across bonds and quarters.
    """
    # -------------------------------------------------
    # 1. DATA ACQUISITION: Download Treasury yields from FRED
    # -------------------------------------------------
    # FRED series for U.S. Treasury yields:
    # 'DGS2'   = 2-Year, 'DGS5'  = 5-Year, 'DGS10' = 10-Year,
    # 'DGS20'  = 20-Year, 'DGS30' = 30-Year.
    series = ['DGS2', 'DGS5', 'DGS10', 'DGS20', 'DGS30']
    yields_df = web.DataReader(series, 'fred', start_date, end_date)
    
    # Drop any days with missing data and rename columns for clarity.
    yields_df = yields_df.dropna()
    yields_df.columns = ['2Y', '5Y', '10Y', '20Y', '30Y']
    
    # -------------------------------------------------
    # 2. RESAMPLE THE DATA TO A QUARTERLY SNAPSHOT
    # -------------------------------------------------
    # We'll use the last available observation in each quarter.
    quarterly_yields = yields_df.resample('Q').last()
    
    # -------------------------------------------------
    # 3. DEFINE THE ROLL-DOWN EXPECTED RETURN MODEL
    # -------------------------------------------------
    # The holding period T is 0.25 years by default.
    # For a zero-coupon bond with current yield y and maturity M, if held for T years,
    # its new yield y_new is determined by linearly interpolating the yield curve at (M - T).
    def compute_expected_return(maturity, current_yield, maturities, yield_curve, T):
        """
        Calculate the expected annualized return for a bond with a given maturity.
        
        Parameters:
            maturity (float): The bond's current maturity (in years).
            current_yield (float): The current yield (as decimal) at that maturity.
            maturities (np.array): Array of benchmark maturities (e.g., [2, 5, 10, 20, 30]).
            yield_curve (np.array): Array of yields (as decimals) corresponding to the maturities.
            T (float): The holding period in years (e.g., 0.25 for quarterly).
        
        Returns:
            float: The approximated expected annualized return.
        """
        new_maturity = maturity - T
        # For values below the minimum available maturity, use the 2Y yield.
        y_new = np.interp(new_maturity, maturities, yield_curve, left=yield_curve[0], right=yield_curve[-1])
        return (current_yield * maturity - y_new * (maturity - T)) / T
    
    # Define maturities corresponding to the yield series.
    maturities = np.array([2, 5, 10, 20, 30], dtype=float)
    
    # -------------------------------------------------
    # 4. COMPUTE EXPECTED RETURNS FOR EACH QUARTER AND BOND
    # -------------------------------------------------
    # Prepare a DataFrame to store the computed expected returns.
    expected_returns_quarterly = pd.DataFrame(index=quarterly_yields.index,
                                              columns=['2Y','5Y','10Y','20Y','30Y'])
    
    # Loop over each quarter.
    for date, row in quarterly_yields.iterrows():
        # Retrieve the yield curve for this quarter and convert from percentage to decimal.
        yield_curve = np.array([row['2Y'], row['5Y'], row['10Y'], row['20Y'], row['30Y']], dtype=float) / 100.0
        for i, mat in enumerate(maturities):
            exp_ret = compute_expected_return(mat, yield_curve[i], maturities, yield_curve, T)
            expected_returns_quarterly.loc[date, f'{int(mat)}Y'] = exp_ret
    
    # Convert expected returns to numeric format.
    expected_returns_quarterly = expected_returns_quarterly.astype(float)
    
    # Print the quarterly expected returns.
    print("Quarterly Expected Annualized Returns (based on roll-down valuation):")
    print(expected_returns_quarterly)
    
    # -------------------------------------------------
    # 5. VISUALIZATION
    # -------------------------------------------------
    if plot_results:
        plt.figure(figsize=(10, 6))
        for col in expected_returns_quarterly.columns:
            plt.plot(expected_returns_quarterly.index, expected_returns_quarterly[col],
                     marker='o', linestyle='-', label=f'{col} Bond')
        plt.xlabel('Quarter')
        plt.ylabel('Expected Annualized Return')
        plt.title('Quarterly Expected Annualized Returns by Bond Maturity')
        plt.legend()
        plt.show()
    
    # Compute an overall expected annual return as the simple average across all bonds and quarters.
    overall_expected_return = expected_returns_quarterly.mean().mean()
    
    return expected_returns_quarterly, overall_expected_return


# Allow this module to run standalone for testing.
if __name__ == "__main__":
    start_date = Start_Date
    end_date = End_Date
    expected_returns_quarterly, overall_expected_return = get_bond_portfolio(start_date, end_date, T=0.25, plot_results=True)
    
    print("\nOverall Expected Annual Return (average across bonds and quarters): {:.2f}%".format(overall_expected_return * 100))



================================================
File: scripts/config.py
================================================
Start_Date = "2019-01-01"
End_Date = "2025-01-01"


================================================
File: scripts/equities.py
================================================
# equities.py

import numpy as np
import pandas as pd
import yfinance as yf
import matplotlib.pyplot as plt
from config import Start_Date, End_Date

def get_equity_portfolio(start_date, end_date, risk_free_rate=0.02, plot_frontier=False):
    """
    Builds an equity portfolio based on U.S. sector ETFs using CAPM expected returns,
    with quarterly rebalancing. For each quarter, the function uses all available 
    data up to that rebalance date to compute CAPM betas, expected returns, and an 
    annualized covariance matrix. It then runs a Monte Carlo simulation (10,000 iterations) 
    to identify the optimal allocation (maximizing the Sharpe ratio) which is applied 
    for that quarter.
    
    In this version, instead of generating daily returns, the portfolio return is 
    computed for each quarter (by compounding the daily returns over the quarter).
    
    Additionally, if plot_frontier=True, the efficient frontier is plotted only for the first quarter.
    
    Finally, the function computes the quarterly returns and cumulative returns and also
    overlays the benchmark (SPY) quarterly cumulative returns on the final plot.
    
    Parameters:
        start_date (str): The start date (format 'YYYY-MM-DD').
        end_date (str): The end date (format 'YYYY-MM-DD').
        risk_free_rate (float): Annual risk-free rate assumption (default: 0.02).
        plot_frontier (bool): Whether to show the efficient frontier plot for the first quarter.
        
    Returns:
        equity_quarterly_returns (pd.Series): Quarterly returns of the equity portfolio.
        equity_cum_returns (pd.Series): Cumulative returns (quarterly compounding) of the equity portfolio.
        equity_expected_return (float): Time-weighted average expected annual return from CAPM estimates.
    """
    # Define sector ETFs and benchmark (SPY)
    sector_etfs = ['XLY',  # Consumer Discretionary
                   'XLP',  # Consumer Staples
                   'XLE',  # Energy
                   'XLF',  # Financials
                   'XLV',  # Health Care
                   'XLI',  # Industrials
                   'XLB',  # Materials
                   'XLRE', # Real Estate
                   'XLK',  # Technology
                   'XLU',  # Utilities
                   'XLC']  # Communication Services
    benchmark_ticker = 'SPY'
    
    # Download adjusted close prices.
    tickers = sector_etfs + [benchmark_ticker]
    price_data = yf.download(tickers, start=start_date, end=end_date, auto_adjust=True)['Close']
    price_data = price_data.dropna()
    
    # Calculate daily returns.
    daily_returns = price_data.pct_change().dropna()
    
    # Determine quarterly rebalancing dates using quarter start frequency.
    # These dates are the first trading day of each quarter.
    rebalance_dates = daily_returns.resample('QS').first().index
    rebalance_dates = rebalance_dates[rebalance_dates >= daily_returns.index[0]]
    
    quarterly_returns_list = []  # to store one return per quarter
    exp_ret_list = []            # list of quarter CAPM expected return estimates (averaged over ETFs)
    weight_records = []          # record optimal weights by quarter
    
    for i, rebalance_date in enumerate(rebalance_dates):
        # Calibration period: all data up to and including the current rebalance date.
        calib_data = daily_returns.loc[:rebalance_date]
        etf_calib = calib_data[sector_etfs]
        bench_calib = calib_data[benchmark_ticker]
        
        # Compute annualized benchmark return using calibration data.
        avg_daily_bench = bench_calib.mean()
        annual_market_return = (1 + avg_daily_bench)**252 - 1
        
        # Compute CAPM beta and expected annual returns for each ETF.
        betas = {}
        expected_returns = {}
        for etf in sector_etfs:
            cov = np.cov(etf_calib[etf], bench_calib)[0, 1]
            var = bench_calib.var()
            beta = cov / var if var != 0 else 0
            betas[etf] = beta
            expected_returns[etf] = risk_free_rate + beta * (annual_market_return - risk_free_rate)
        exp_ret_series = pd.Series(expected_returns)
        exp_ret_list.append(exp_ret_series.mean())
        
        # Compute the annualized covariance matrix.
        cov_daily = etf_calib.cov()
        cov_matrix = cov_daily * 252
        
        # Monte Carlo simulation for optimal portfolio allocation.
        num_portfolios = 10000
        results = []
        num_assets = len(sector_etfs)
        np.random.seed(42)
        for _ in range(num_portfolios):
            weights = np.random.random(num_assets)
            weights /= np.sum(weights)
            port_return = np.sum(exp_ret_series.values * weights)
            port_volatility = np.sqrt(np.dot(weights.T, np.dot(cov_matrix, weights)))
            sharpe_ratio = (port_return - risk_free_rate) / port_volatility if port_volatility != 0 else 0
            results.append({
                'Return': port_return,
                'Volatility': port_volatility,
                'Sharpe': sharpe_ratio,
                'Weights': weights
            })
        results_df = pd.DataFrame(results)
        max_sharpe_idx = results_df['Sharpe'].idxmax()
        max_sharpe_portfolio = results_df.loc[max_sharpe_idx]
        optimal_weights = pd.Series(max_sharpe_portfolio['Weights'], index=sector_etfs)
        weight_records.append((rebalance_date, optimal_weights))
        
        # Plot the efficient frontier for the first quarter if requested (optional).
        '''
        if plot_frontier and i == 0:
            plt.figure(figsize=(10, 6))
            sc = plt.scatter(results_df['Volatility'], results_df['Return'], 
                             c=results_df['Sharpe'], cmap='viridis', marker='o', s=10, alpha=0.5)
            plt.colorbar(sc, label='Sharpe Ratio')
            plt.scatter(max_sharpe_portfolio['Volatility'], max_sharpe_portfolio['Return'], 
                        color='red', marker='*', s=500, label='Max Sharpe')
            plt.xlabel('Annualized Volatility')
            plt.ylabel('Annualized Return')
            plt.title(f'Efficient Frontier (Rebalance: {rebalance_date.date()})')
            plt.legend()
            plt.show()
        '''
        # Determine the period over which to calculate the portfolio return.
        # Here, we want to do the calculation at the end of the period (quarter-end) before the new one starts.
        if i < len(rebalance_dates) - 1:
            # Get all trading days from the current rebalance date until the next quarter's start.
            period_data = daily_returns.loc[rebalance_date:rebalance_dates[i+1]]
            # The period_end is the last trading day in this interval.
            period_end = period_data.index[-1]
        else:
            period_end = daily_returns.index[-1]
        
        # Extract daily returns for the current quarter period.
        quarter_data = daily_returns.loc[rebalance_date:period_end, sector_etfs]
        # Compute the portfolio daily returns for the quarter.
        portfolio_daily = (quarter_data * optimal_weights).sum(axis=1)
        # Compute the quarterly return by compounding daily returns.
        quarter_return = (1 + portfolio_daily).prod() - 1
        # The quarter return is assigned the timestamp of the period_end.
        quarterly_returns_list.append(pd.Series(quarter_return, index=[period_end]))
    
    # Concatenate quarterly returns into one Series and compute cumulative returns.
    equity_quarterly_returns = pd.concat(quarterly_returns_list).sort_index()
    equity_cum_returns = (1 + equity_quarterly_returns).cumprod()
    
    # Compute time-weighted average expected annual return (weighted by number of days in each quarter).
    quarter_lengths = [
        len(daily_returns.loc[rebalance_dates[i]:rebalance_dates[i+1]])
        if i < len(rebalance_dates)-1 else len(daily_returns.loc[rebalance_dates[i]:])
        for i in range(len(rebalance_dates))
    ]
    weighted_exp_return = np.average(exp_ret_list, weights=quarter_lengths)
    
    # Compute benchmark (SPY) quarterly returns.
    spy_data = price_data[benchmark_ticker]
    spy_quarterly = spy_data.resample('Q').last().pct_change().dropna()
    spy_cum_returns = (1 + spy_quarterly).cumprod()
    
    return equity_quarterly_returns, equity_cum_returns, weighted_exp_return

# Allow the module to run standalone for testing.
if __name__ == "__main__":
    start_date = Start_Date
    end_date = End_Date
    risk_free_rate = 0.02
    
    eq_qtr, eq_cum, eq_exp_return = get_equity_portfolio(start_date, end_date, risk_free_rate, plot_frontier=False)
    
    print("\nEquity Portfolio Quarterly Testing:")
    print("Final Cumulative Return: {:.2f}".format(eq_cum.iloc[-1]))
    print("Time-Weighted Average Expected Annual Return: {:.2f}%".format(eq_exp_return * 100))
    
    plt.figure(figsize=(10,6))
    plt.plot(eq_cum.index, eq_cum, label="Equity Portfolio Cumulative Returns")
    plt.xlabel("Date")
    plt.ylabel("Cumulative Return")
    plt.title("Equity Portfolio (Quarterly Rebalancing) Backtest")
    plt.legend()
    plt.show()



================================================
File: scripts/portfolio.py
================================================
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import yfinance as yf

# Import our portfolio functions from equities.py and bonds.py.
from equities import get_equity_portfolio
from bonds import get_bond_portfolio
from config import Start_Date, End_Date
# ======================================================
# 1. Set analysis parameters
# ======================================================
risk_free_rate = 0.02   # Annual risk-free rate

# For testing, set allocation weights so that the combined returns should match one asset exactly.
equity_weight = 0.7  
bond_weight = 0.3  

# ======================================================
# 2. Build the individual sub-portfolios (Quarterly)
# ======================================================

# Equity Portfolio: quarterly rebalanced returns
eq_quarterly_returns, eq_cum_returns, equity_expected_return = get_equity_portfolio(
    Start_Date, End_Date, risk_free_rate, plot_frontier=True
)

# Ensure the indices are datetime objects.
eq_quarterly_returns.index = pd.to_datetime(eq_quarterly_returns.index)
eq_cum_returns.index = pd.to_datetime(eq_cum_returns.index)

# Adjust the equity index to quarter-end (subtract one day from the next quarter's start).
eq_quarterly_returns.index = eq_quarterly_returns.index - pd.Timedelta(days=1)
eq_cum_returns.index = eq_cum_returns.index - pd.Timedelta(days=1)

# Bond Portfolio:
bond_expected_df, bond_expected_return = get_bond_portfolio(Start_Date, End_Date, T=0.25, plot_results=False)
bond_price = yf.download('TLT', start=Start_Date, end=End_Date, auto_adjust=True)['Close'].dropna()
# Resample TLT to quarter-end dates using 'QE' then compute quarterly returns.
bond_quarterly_returns = bond_price.resample('QE').last().pct_change().dropna()
bond_quarterly_returns.index = pd.to_datetime(bond_quarterly_returns.index)

# If bond_quarterly_returns is a DataFrame with one column, convert it to a Series.
if isinstance(bond_quarterly_returns, pd.DataFrame) and bond_quarterly_returns.shape[1] == 1:
    bond_quarterly_returns = bond_quarterly_returns.iloc[:, 0]

bond_cum_returns = (1 + bond_quarterly_returns).cumprod()

# ======================================================
# 3. Combine sub-portfolios into a Combined Portfolio (Quarterly)
# ======================================================

# Define common quarter-end dates from both series.
common_dates = eq_quarterly_returns.index.intersection(bond_quarterly_returns.index)
print("Common Dates (Quarter-End):")
print(common_dates)

# Use .loc[â€¦] to extract only those common dates (without fill_value, to avoid introducing zeros).
eq_qtr = eq_quarterly_returns.loc[common_dates]
bond_qtr = bond_quarterly_returns.loc[common_dates]

# --- Debug: Inspect the aligned quarterly returns.
print("\nEquity Quarterly Returns (Aligned):")
print(eq_qtr)
print("\nBond Quarterly Returns (Aligned):")
print(bond_qtr)

# Compute the combined quarterly returns.
combined_qtr_returns = equity_weight * eq_qtr + bond_weight * bond_qtr
print("\nCombined Quarterly Returns (should equal Equity Quarterly Returns when weights are 1.0 and 0.0):")
print(combined_qtr_returns)

# Compute cumulative returns for the combined portfolio.
combined_cum_returns = (1 + combined_qtr_returns).cumprod()

# For a direct comparison, align the equity cumulative returns to the same common dates:
eq_cum_returns_aligned = eq_cum_returns.loc[common_dates]
print("\nEquity Cumulative Returns (Aligned):")
print(eq_cum_returns_aligned)
print("\nCombined Cumulative Returns (Should match Equity Cumulative Returns):")
print(combined_cum_returns)

# ======================================================
# 4. Benchmark: SPY Quarterly Returns
# ======================================================
spy_price = yf.download('SPY', start=Start_Date, end=End_Date, auto_adjust=True)['Close'].dropna()
# Resample SPY to quarter-end dates using 'QE' then compute quarterly returns.
spy_qtr_returns = spy_price.resample('QE').last().pct_change().dropna()
spy_qtr_returns.index = pd.to_datetime(spy_qtr_returns.index)
spy_cum_returns = (1 + spy_qtr_returns).cumprod()

# ======================================================
# 5. Display Overall Portfolio Performance & Risk Metrics
# ======================================================
print("\nPerformance Metrics:")
print("Equity Portfolio Expected Annual Return: {:.2f}%".format(equity_expected_return * 100))
print("Bond Portfolio Expected Annual Return: {:.2f}%".format(bond_expected_return * 100))
combined_expected_return = equity_weight * equity_expected_return + bond_weight * bond_expected_return
print("Combined Portfolio Expected Annual Return: {:.2f}%".format(combined_expected_return * 100))

# Annualized volatility (using quarterly returns, multiply by sqrt(4)).
combined_volatility = combined_qtr_returns.std() * np.sqrt(4)
print("Combined Portfolio Annualized Volatility: {:.2f}%".format(combined_volatility * 100))

# ======================================================
# 6. Plot Performance (Cumulative Returns)
# ======================================================

# Align the bond cumulative returns to the common dates.
# (Assuming bond_cum_returns was computed on bond_quarterly_returns before intersection.)
bond_cum_returns_aligned = bond_cum_returns.loc[common_dates]

# Create a new figure for the cumulative returns plot.
plt.figure(figsize=(12, 6))

# Plot the equity portfolio cumulative returns.
plt.plot(eq_cum_returns_aligned.index, eq_cum_returns_aligned.values,
         label="Equity Portfolio", marker="o")

# Plot the bond portfolio cumulative returns.
plt.plot(bond_cum_returns_aligned.index, bond_cum_returns_aligned.values,
         label="Bond Portfolio", marker="o")

# Plot the combined portfolio cumulative returns.
plt.plot(combined_cum_returns.index, combined_cum_returns.values,
         label="Actual Portfolio", marker="o")

# Plot the benchmark (SPY) cumulative returns.
plt.plot(spy_cum_returns.index, spy_cum_returns.values,
         label="Benchmark (SPY)", marker="o")

# Labeling the plot.
plt.title("Cumulative Returns Comparison")
plt.xlabel("Date")
plt.ylabel("Cumulative Return")
plt.legend()
plt.grid(True)
plt.savefig("cumulative_returns_comparison.png", dpi=300, bbox_inches='tight')

# Display the plot.
plt.show()



